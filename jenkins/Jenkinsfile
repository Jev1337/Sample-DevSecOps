pipeline {
    agent any

    environment {
        REGISTRY = 'localhost:32000'
        IMAGE_NAME = 'flask-k8s-app'
        TAG = "build-${env.BUILD_NUMBER}"
        SONAR_HOST_URL = "http://sonarqube.local:9000"
        SONAR_PROJECT_KEY = "flask-k8s-devsecops"
        SONAR_TOKEN = credentials('SONAR_TOKEN')
    }

    stages {
        stage('Checkout') {
            steps {
                checkout scm
            }
        }

        stage('Install Dependencies') {
            steps {
                dir('app') {
                    sh '''
                        python3 -m venv venv
                        . venv/bin/activate
                        python -m pip install --upgrade pip
                        python -m pip install -r requirements.txt
                    '''
                }
            }
        }

        stage('Run Tests') {
            steps {
                dir('app') {
                    sh '''
                        . venv/bin/activate
                        python -m pytest tests/ -v \
                            --cov=. \
                            --cov-report=xml \
                            --cov-report=html \
                            --junitxml=test-results.xml
                    '''
                }
            }
            post {
                always {
                    archiveArtifacts artifacts: 'app/htmlcov/**/*', allowEmptyArchive: true
                    junit 'app/test-results.xml'
                }
            }
        }
        /*
        stage('SonarQube Analysis') {
            steps {
                script {
                    withSonarQubeEnv('SonarQube') {
                        dir('app') {
                            sh '''
                                sonar-scanner \
                                    -Dsonar.projectKey=${SONAR_PROJECT_KEY} \
                                    -Dsonar.sources=. \
                                    -Dsonar.host.url=${SONAR_HOST_URL} \
                                    -Dsonar.login=${SONAR_TOKEN} \
                                    -Dsonar.python.coverage.reportPaths=coverage.xml \
                                    -Dsonar.python.xunit.reportPath=test-results.xml
                            '''
                        }
                    }
                }
            }
        }
        */

        stage('Trivy FS Scan') {
            steps {
                sh "trivy fs --format table -o trivy-fs-report.txt --severity HIGH,CRITICAL ."
                archiveArtifacts artifacts: 'trivy-fs-report.txt', allowEmptyArchive: true
            }
        }

        stage('Build & Push Image') {
            steps {
                script {
                    def fullImageName = "${env.REGISTRY}/${env.IMAGE_NAME}:${env.TAG}"
                    def buildNumber = env.BUILD_NUMBER
                    
                    // Get current git info
                    def gitCommit = sh(script: 'git rev-parse HEAD', returnStdout: true).trim()
                    def gitUrl = sh(script: 'git config --get remote.origin.url', returnStdout: true).trim()
                    
                    sh """
                        # Create simple Kaniko job with git context
                        cat > kaniko-job.yaml << 'EOF'
apiVersion: batch/v1
kind: Job
metadata:
  name: kaniko-build-${buildNumber}
  namespace: jenkins
spec:
  template:
    spec:
      restartPolicy: Never
      containers:
      - name: kaniko
        image: gcr.io/kaniko-project/executor:latest
        args:
        - "--context=git://${gitUrl}#${gitCommit}"
        - "--context-sub-path=app"
        - "--dockerfile=app/Dockerfile"
        - "--destination=${fullImageName}"
        - "--insecure"
        - "--skip-tls-verify"
        - "--verbosity=info"
        env:
        - name: GIT_USERNAME
          value: ""
        - name: GIT_PASSWORD  
          value: ""
EOF
                        
                        # Apply and wait for job
                        kubectl apply -f kaniko-job.yaml
                        
                        echo "Waiting for Kaniko build job to complete..."
                        kubectl wait --for=condition=complete job/kaniko-build-${buildNumber} -n jenkins --timeout=600s
                        
                        # Check if job succeeded
                        JOB_STATUS=\$(kubectl get job kaniko-build-${buildNumber} -n jenkins -o jsonpath='{.status.conditions[0].type}')
                        if [ "\$JOB_STATUS" = "Complete" ]; then
                            echo "‚úÖ Build completed successfully"
                        else
                            echo "‚ùå Build failed - getting logs"
                            kubectl logs -n jenkins -l job-name=kaniko-build-${buildNumber} --tail=50
                            exit 1
                        fi
                        
                        # Show final logs
                        echo "Build logs:"
                        kubectl logs -n jenkins -l job-name=kaniko-build-${buildNumber} --tail=10
                        
                        # Cleanup
                        kubectl delete job kaniko-build-${buildNumber} -n jenkins
                        rm -f kaniko-job.yaml
                        
                        echo "Successfully built and pushed ${fullImageName}"
                    """
                }
            }
        }

        stage('Trivy Image Scan') {
            steps {
                script {
                    def fullImageName = "${env.REGISTRY}/${env.IMAGE_NAME}:${env.TAG}"
                    sh "trivy image --format table -o trivy-image-report.txt --severity HIGH,CRITICAL ${fullImageName} || true"
                }
                archiveArtifacts artifacts: 'trivy-image-report.txt', allowEmptyArchive: true
            }
        }

        stage('Deploy to Kubernetes') {
            steps {
                script {
                    def fullImageName = "${env.REGISTRY}/${env.IMAGE_NAME}:${env.TAG}"
                    
                    // Update deployment using kubectl (Jenkins has cluster-admin access)
                    sh """
                        # Update the deployment with new image
                        kubectl set image deployment/flask-app flask-app=${fullImageName} -n flask-app
                        
                        # Wait for rollout to complete
                        kubectl rollout status deployment/flask-app -n flask-app --timeout=300s
                        
                        # Verify deployment
                        kubectl get pods -n flask-app -l app=flask-app
                        
                        echo "Deployment updated successfully with image: ${fullImageName}"
                    """
                }
            }
        }

        stage('Generate Security Report') {
            steps {
                script {
                    // Generate a comprehensive security report
                    sh '''
                        mkdir -p security/reports
                        
                        # Create HTML security dashboard
                        cat > security/reports/security-dashboard.html << 'EOL'
<!DOCTYPE html>
<html>
<head>
    <title>DevSecOps Security Dashboard - Build ${BUILD_NUMBER}</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .header { background-color: #f4f4f4; padding: 20px; border-radius: 5px; }
        .section { margin: 20px 0; padding: 15px; border: 1px solid #ddd; border-radius: 5px; }
        .success { background-color: #d4edda; border-color: #c3e6cb; }
        .warning { background-color: #fff3cd; border-color: #ffeaa7; }
        .error { background-color: #f8d7da; border-color: #f5c6cb; }
        pre { background-color: #f8f9fa; padding: 10px; border-radius: 3px; overflow-x: auto; }
        .timestamp { color: #666; font-size: 0.9em; }
    </style>
</head>
<body>
    <div class="header">
        <h1>DevSecOps Security Dashboard</h1>
        <p>Build #${BUILD_NUMBER} - Generated on $(date)</p>
        <p>Jenkins Job: ${JOB_NAME}</p>
        <p>Git Commit: ${GIT_COMMIT}</p>
    </div>
    
    <div class="section success">
        <h2>‚úÖ Pipeline Status</h2>
        <p>Build completed successfully with security scans</p>
        <p>Image: ${REGISTRY}/${IMAGE_NAME}:${TAG}</p>
    </div>
    
    <div class="section">
        <h2>üìä Security Scan Results</h2>
        <p>Filesystem and container image scanned for vulnerabilities</p>
        <ul>
            <li>Trivy Filesystem Scan: Available in build artifacts</li>
            <li>Trivy Image Scan: Available in build artifacts</li>
            <li>SonarQube Analysis: Check SonarQube dashboard</li>
        </ul>
    </div>
    
    <div class="section">
        <h2>üîó Links</h2>
        <ul>
            <li><a href="${BUILD_URL}">Jenkins Build</a></li>
            <li><a href="${SONAR_HOST_URL}/dashboard?id=${SONAR_PROJECT_KEY}">SonarQube Project</a></li>
            <li><a href="http://grafana.local">Grafana Dashboard</a></li>
        </ul>
    </div>
    
    <div class="timestamp">
        Report generated at $(date)
    </div>
</body>
</html>
EOL
                        
                        echo "Security dashboard generated"
                    '''
                    
                    archiveArtifacts artifacts: 'security/reports/security-dashboard.html', allowEmptyArchive: true
                }
            }
        }
    }

    post {
        always {
            echo 'Pipeline execution completed'
            
            // Clean up any temporary files
            sh 'rm -f kaniko-job.yaml || true'
        }
        
        success {
            echo '‚úÖ Pipeline completed successfully!'
        }
        
        failure {
            echo '‚ùå Pipeline failed. Check the logs for details.'
        }
        
        unstable {
            echo '‚ö†Ô∏è Pipeline completed with warnings.'
        }
    }
}
