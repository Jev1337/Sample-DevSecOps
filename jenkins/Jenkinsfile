pipeline {
    agent any

    environment {
        REGISTRY = 'localhost:32000'
        IMAGE_NAME = 'flask-k8s-app'
        TAG = "build-${env.BUILD_NUMBER}"
        SONAR_HOST_URL = "http://10.152.183.26:9000"
        SONAR_PROJECT_KEY = "flask-k8s-devsecops"
        SONAR_TOKEN = credentials('SONAR_TOKEN')
    }

    stages {
        stage('Checkout SCM') {
            steps {
                checkout scm
            }
        }

        stage('Install Dependencies') {
            steps {
                script {
                    dir('app') {
                        sh 'python3 -m venv venv'
                        sh '. venv/bin/activate && python -m pip install --upgrade pip'
                        sh '. venv/bin/activate && python -m pip install -r requirements.txt'
                    }
                }
            }
        }

        stage('Run Tests') {
            steps {
                script {
                    dir('app') {
                        sh '. venv/bin/activate && python -m pytest tests/ -v --cov=. --cov-report=xml --cov-report=html --junitxml=test-results.xml'
                    }
                }
            }
            post {
                always {
                    archiveArtifacts artifacts: 'app/htmlcov/**/*', allowEmptyArchive: true
                    junit 'app/test-results.xml'
                }
            }
        }

        /*
        stage('SonarQube Analysis') {
            steps {
                script {
                    withSonarQubeEnv('SonarQube') {
                        dir('app') {
                            sh '''
                            sonar-scanner \
                                -Dsonar.projectKey=${SONAR_PROJECT_KEY} \
                                -Dsonar.sources=. \
                                -Dsonar.host.url=${SONAR_HOST_URL} \
                                -Dsonar.login=${SONAR_TOKEN} \
                                -Dsonar.python.coverage.reportPaths=coverage.xml \
                                -Dsonar.python.xunit.reportPath=test-results.xml
                            '''
                        }
                    }
                }
            }
        }
        */

        stage('Trivy FS Scan') {
            steps {
                sh "trivy fs --format table -o trivy-fs-report.txt --severity HIGH,CRITICAL ."
                archiveArtifacts artifacts: 'trivy-fs-report.txt', allowEmptyArchive: true
            }
        }

        stage('Build & Deploy via Kubernetes') {
            steps {
                script {
                    def fullImageName = "${env.REGISTRY}/${env.IMAGE_NAME}:${env.TAG}"
                    
                    // Create BuildKit job to build and push image
                    sh """
                        python3 << 'EOF'
import os
from kubernetes import client, config

# Load in-cluster config
config.load_incluster_config()

# Create Kubernetes API client
v1 = client.CoreV1Api()
batch_v1 = client.BatchV1Api()

# Define BuildKit job
job_manifest = {
    "apiVersion": "batch/v1",
    "kind": "Job",
    "metadata": {
        "name": "build-${env.BUILD_NUMBER}",
        "namespace": "jenkins"
    },
    "spec": {
        "template": {
            "spec": {
                "restartPolicy": "Never",
                "containers": [{
                    "name": "buildkit",
                    "image": "moby/buildkit:latest",
                    "command": ["buildctl-daemonless.sh"],
                    "args": [
                        "build",
                        "--frontend", "dockerfile.v0",
                        "--local", "context=/workspace",
                        "--local", "dockerfile=/workspace",
                        "--output", "type=image,name=${fullImageName},push=true"
                    ],
                    "volumeMounts": [{
                        "name": "workspace",
                        "mountPath": "/workspace"
                    }],
                    "securityContext": {
                        "privileged": True
                    }
                }],
                "volumes": [{
                    "name": "workspace",
                    "hostPath": {
                        "path": "${env.WORKSPACE}/app"
                    }
                }]
            }
        }
    }
}

# Create the job
batch_v1.create_namespaced_job(namespace="jenkins", body=job_manifest)
print("Build job created successfully")
EOF
                    """
                    
                    // Wait for build job to complete
                    sh """
                        python3 << 'EOF'
import time
from kubernetes import client, config

config.load_incluster_config()
batch_v1 = client.BatchV1Api()

job_name = "build-${env.BUILD_NUMBER}"
namespace = "jenkins"

# Wait for job completion
while True:
    job = batch_v1.read_namespaced_job(name=job_name, namespace=namespace)
    if job.status.conditions:
        for condition in job.status.conditions:
            if condition.type == "Complete" and condition.status == "True":
                print("Build job completed successfully")
                exit(0)
            elif condition.type == "Failed" and condition.status == "True":
                print("Build job failed")
                exit(1)
    time.sleep(10)
EOF
                    """
                }
            }
        }

        stage('Trivy Image Scan') {
            steps {
                script {
                    def fullImageName = "${env.REGISTRY}/${env.IMAGE_NAME}:${env.TAG}"
                    sh "trivy image --format table -o trivy-image-report.txt --severity HIGH,CRITICAL ${fullImageName} || true"
                }
                archiveArtifacts artifacts: 'trivy-image-report.txt', allowEmptyArchive: true
            }
        }

        stage('Deploy to Kubernetes') {
            steps {
                script {
                    def fullImageName = "${env.REGISTRY}/${env.IMAGE_NAME}:${env.TAG}"
                    
                    // Update deployment with new image using Kubernetes API
                    sh """
                        python3 << 'EOF'
from kubernetes import client, config

config.load_incluster_config()
apps_v1 = client.AppsV1Api()

# Update deployment image
deployment = apps_v1.read_namespaced_deployment(name="flask-app", namespace="flask-app")
deployment.spec.template.spec.containers[0].image = "${fullImageName}"

# Apply the update
apps_v1.patch_namespaced_deployment(
    name="flask-app", 
    namespace="flask-app", 
    body=deployment
)

print("Deployment updated with new image: ${fullImageName}")
EOF
                    """
                    
                    // Wait for rollout to complete
                    sh """
                        python3 << 'EOF'
import time
from kubernetes import client, config

config.load_incluster_config()
apps_v1 = client.AppsV1Api()

deployment_name = "flask-app"
namespace = "flask-app"

# Wait for rollout to complete
for i in range(30):  # 5 minute timeout
    deployment = apps_v1.read_namespaced_deployment(name=deployment_name, namespace=namespace)
    if (deployment.status.ready_replicas == deployment.spec.replicas and 
        deployment.status.updated_replicas == deployment.spec.replicas):
        print("Deployment rollout completed successfully")
        break
    time.sleep(10)
else:
    print("Deployment rollout timed out")
    exit(1)
EOF
                    """
                }
            }
        }
    }

    post {
        always {
            echo 'Pipeline finished.'
        }
    }
}
