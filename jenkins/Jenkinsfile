pipeline {
    agent any

    environment {
        REGISTRY = 'localhost:32000'
        IMAGE_NAME = 'flask-k8s-app'
        TAG = "build-${env.BUILD_NUMBER}"
        SONAR_HOST_URL = "http://10.152.183.26:9000"
        SONAR_PROJECT_KEY = "flask-k8s-devsecops"
        SONAR_TOKEN = credentials('SONAR_TOKEN')
    }

    stages {
        stage('Checkout SCM') {
            steps {
                checkout scm
            }
        }

        stage('Install Dependencies') {
            steps {
                script {
                    dir('app') {
                        sh 'python3 -m venv venv'
                        sh '. venv/bin/activate && python -m pip install --upgrade pip'
                        sh '. venv/bin/activate && python -m pip install -r requirements.txt'
                    }
                }
            }
        }

        stage('Run Tests') {
            steps {
                script {
                    dir('app') {
                        sh '. venv/bin/activate && python -m pytest tests/ -v --cov=. --cov-report=xml --cov-report=html --junitxml=test-results.xml'
                    }
                }
            }
            post {
                always {
                    archiveArtifacts artifacts: 'app/htmlcov/**/*', allowEmptyArchive: true
                    junit 'app/test-results.xml'
                }
            }
        }

        /*
        stage('SonarQube Analysis') {
            steps {
                script {
                    withSonarQubeEnv('SonarQube') {
                        dir('app') {
                            sh '''
                            sonar-scanner \
                                -Dsonar.projectKey=${SONAR_PROJECT_KEY} \
                                -Dsonar.sources=. \
                                -Dsonar.host.url=${SONAR_HOST_URL} \
                                -Dsonar.login=${SONAR_TOKEN} \
                                -Dsonar.python.coverage.reportPaths=coverage.xml \
                                -Dsonar.python.xunit.reportPath=test-results.xml
                            '''
                        }
                    }
                }
            }
        }
        */

        stage('Trivy FS Scan') {
            steps {
                sh "trivy fs --format table -o trivy-fs-report.txt --severity HIGH,CRITICAL ."
                archiveArtifacts artifacts: 'trivy-fs-report.txt', allowEmptyArchive: true
            }
        }

        stage('Build & Push Image') {
            steps {
                script {
                    // Checkout SCM and set Git context for Kaniko
                    def scmVars = checkout scm
                    env.SCM_URL = scmVars.GIT_URL
                    env.BRANCH_NAME = scmVars.GIT_BRANCH
                    def fullImageName = "${env.REGISTRY}/${env.IMAGE_NAME}:${env.TAG}"
                    def buildNumber = env.BUILD_NUMBER
                    
                    // Create Kaniko build job using Git context
                    writeFile file: 'kaniko-job.yaml', text: """
apiVersion: batch/v1
kind: Job
metadata:
  name: build-${buildNumber}
  namespace: jenkins
spec:
  template:
    spec:
      restartPolicy: Never
      containers:
      - name: kaniko
        image: gcr.io/kaniko-project/executor:latest
        args:
        - "--context=${SCM_URL}#${BRANCH_NAME}"
        - "--dockerfile=Dockerfile"
        - "--destination=${fullImageName}"
        - "--insecure"
        - "--skip-tls-verify"
      restartPolicy: Never
"""
                    
                    sh '''
python3 -c "
from kubernetes import client, config, utils
import yaml

config.load_incluster_config()
k8s_client = client.ApiClient()

with open('kaniko-job.yaml', 'r') as f:
    job_manifest = yaml.safe_load(f)

utils.create_from_dict(k8s_client, job_manifest)
print('Kaniko build job created')
"
                    '''
                    
                    // Wait for job completion
                    sh """
python3 -c "
import time
from kubernetes import client, config

config.load_incluster_config()
batch_v1 = client.BatchV1Api()
v1 = client.CoreV1Api()

job_name = 'build-${buildNumber}'
namespace = 'jenkins'

print('Waiting for build job to complete...')
for i in range(18):  # 3 minute timeout
    try:
        job = batch_v1.read_namespaced_job(name=job_name, namespace=namespace)
        
        # Check pod status and logs
        pods = v1.list_namespaced_pod(namespace=namespace, label_selector=f'job-name={job_name}')
        if pods.items:
            pod = pods.items[0]
            pod_name = pod.metadata.name
            pod_phase = pod.status.phase
            print(f'Kaniko pod: {pod_name}, Phase: {pod_phase}')
            
            # If pod is running for a while, check logs
            if i > 2 and pod_phase == 'Running':
                try:
                    logs = v1.read_namespaced_pod_log(name=pod_name, namespace=namespace, tail_lines=50)
                    print(f'Recent logs from pod {pod_name}:')
                    print(logs)
                except Exception as log_error:
                    print(f'Could not get logs: {log_error}')
            
            # Check for failed pod
            if pod_phase == 'Failed':
                print(f'Pod {pod_name} failed')
                try:
                    logs = v1.read_namespaced_pod_log(name=pod_name, namespace=namespace)
                    print('Pod logs:')
                    print(logs)
                except:
                    pass
                exit(1)
                
        if job.status.conditions:
            for condition in job.status.conditions:
                if condition.type == 'Complete' and condition.status == 'True':
                    print('Build job completed successfully')
                    exit(0)
                elif condition.type == 'Failed' and condition.status == 'True':
                    print('Build job failed')
                    exit(1)
        
        print(f'Waiting... (attempt {i+1}/18)')
        time.sleep(10)
    except Exception as e:
        print(f'Error checking job status: {e}')
        time.sleep(10)

print('Build job timed out - checking final status')
# Final check - get logs regardless
try:
    pods = v1.list_namespaced_pod(namespace=namespace, label_selector=f'job-name={job_name}')
    if pods.items:
        pod_name = pods.items[0].metadata.name
        logs = v1.read_namespaced_pod_log(name=pod_name, namespace=namespace)
        print('Final pod logs:')
        print(logs)
except Exception as e:
    print(f'Could not get final logs: {e}')
exit(1)
"
                    """
                    
                    // Cleanup job
                    sh """
python3 -c "
from kubernetes import client, config

config.load_incluster_config()
batch_v1 = client.BatchV1Api()

try:
    batch_v1.delete_namespaced_job(name='build-${buildNumber}', namespace='jenkins', 
                                  body=client.V1DeleteOptions(propagation_policy='Foreground'))
    print('Cleanup: Build job deleted')
except Exception as e:
    print(f'Cleanup error: {e}')
"
                    """
                }
            }
        }

        stage('Trivy Image Scan') {
            steps {
                script {
                    def fullImageName = "${env.REGISTRY}/${env.IMAGE_NAME}:${env.TAG}"
                    sh "trivy image --format table -o trivy-image-report.txt --severity HIGH,CRITICAL ${fullImageName} || true"
                }
                archiveArtifacts artifacts: 'trivy-image-report.txt', allowEmptyArchive: true
            }
        }

        stage('Deploy to Kubernetes') {
            steps {
                script {
                    def fullImageName = "${env.REGISTRY}/${env.IMAGE_NAME}:${env.TAG}"
                    
                    // Update deployment with new image using Kubernetes API
                    sh """
                        python3 << 'EOF'
from kubernetes import client, config

config.load_incluster_config()
apps_v1 = client.AppsV1Api()

# Update deployment image
deployment = apps_v1.read_namespaced_deployment(name="flask-app", namespace="flask-app")
deployment.spec.template.spec.containers[0].image = "${fullImageName}"

# Apply the update
apps_v1.patch_namespaced_deployment(
    name="flask-app", 
    namespace="flask-app", 
    body=deployment
)

print("Deployment updated with new image: ${fullImageName}")
EOF
                    """
                    
                    // Wait for rollout to complete
                    sh """
                        python3 << 'EOF'
import time
from kubernetes import client, config

config.load_incluster_config()
apps_v1 = client.AppsV1Api()

deployment_name = "flask-app"
namespace = "flask-app"

# Wait for rollout to complete
for i in range(30):  # 5 minute timeout
    deployment = apps_v1.read_namespaced_deployment(name=deployment_name, namespace=namespace)
    if (deployment.status.ready_replicas == deployment.spec.replicas and 
        deployment.status.updated_replicas == deployment.spec.replicas):
        print("Deployment rollout completed successfully")
        break
    time.sleep(10)
else:
    print("Deployment rollout timed out")
    exit(1)
EOF
                    """
                }
            }
        }
    }

    post {
        always {
            echo 'Pipeline finished.'
        }
    }
}
