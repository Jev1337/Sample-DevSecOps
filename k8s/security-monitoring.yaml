apiVersion: v1
kind: Namespace
metadata:
  name: security
  labels:
    name: security
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: security-monitor-config
  namespace: security
data:
  monitor.py: |
    #!/usr/bin/env python3
    import os
    import time
    import json
    import hashlib
    import requests
    import subprocess
    from datetime import datetime
    from pathlib import Path
    import logging

    # Configure logging
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s [%(levelname)s] %(message)s'
    )

    class SecurityMonitor:
        def __init__(self):
            self.loki_url = os.environ.get('LOKI_URL', 'http://loki.monitoring.svc.cluster.local:3100')
            self.node_name = os.environ.get('NODE_NAME', 'unknown')
            self.last_package_hash = None
            self.init_package_state()

        def init_package_state(self):
            """Initialize the package state tracking"""
            try:
                result = subprocess.run(['dpkg', '-l'], capture_output=True, text=True)
                self.last_package_hash = hashlib.md5(result.stdout.encode()).hexdigest()
            except Exception as e:
                logging.error(f"Failed to initialize package state: {e}")

        def send_to_loki(self, log_entry, stream_labels):
            """Send log entry to Loki"""
            timestamp = str(int(datetime.now().timestamp() * 1000000000))
            
            payload = {
                "streams": [
                    {
                        "stream": stream_labels,
                        "values": [
                            [timestamp, json.dumps(log_entry)]
                        ]
                    }
                ]
            }
            
            try:
                response = requests.post(
                    f'{self.loki_url}/loki/api/v1/push',
                    json=payload,
                    headers={'Content-Type': 'application/json'},
                    timeout=10
                )
                if response.status_code != 204:
                    logging.warning(f"Failed to send to Loki: {response.status_code}")
            except Exception as e:
                logging.error(f"Error sending to Loki: {e}")

        def check_package_changes(self):
            """Monitor package changes"""
            try:
                result = subprocess.run(['dpkg', '-l'], capture_output=True, text=True)
                current_hash = hashlib.md5(result.stdout.encode()).hexdigest()
                
                if self.last_package_hash and current_hash != self.last_package_hash:
                    # Package change detected
                    log_entry = {
                        'timestamp': datetime.now().isoformat(),
                        'node': self.node_name,
                        'event_type': 'package_change_detected',
                        'message': 'System package state changed',
                        'severity': 'medium'
                    }
                    
                    stream_labels = {
                        'job': 'security-monitor',
                        'node': self.node_name,
                        'security_event': 'package_management',
                        'severity': 'medium'
                    }
                    
                    self.send_to_loki(log_entry, stream_labels)
                    self.last_package_hash = current_hash
                    
            except Exception as e:
                logging.error(f"Error checking packages: {e}")

        def check_suspicious_processes(self):
            """Monitor for suspicious processes"""
            suspicious_patterns = [
                'nc -l',  # Netcat listener
                'python -m http.server',  # Simple HTTP server
                'bash -i',  # Interactive bash
                '/tmp/',  # Execution from tmp
                'wget http',  # Downloading files
                'curl -o',  # Downloading files
            ]
            
            try:
                result = subprocess.run(['ps', 'aux'], capture_output=True, text=True)
                
                for line in result.stdout.split('\n'):
                    for pattern in suspicious_patterns:
                        if pattern in line and 'grep' not in line:
                            log_entry = {
                                'timestamp': datetime.now().isoformat(),
                                'node': self.node_name,
                                'event_type': 'suspicious_process',
                                'process_line': line.strip(),
                                'pattern_matched': pattern,
                                'severity': 'high'
                            }
                            
                            stream_labels = {
                                'job': 'security-monitor',
                                'node': self.node_name,
                                'security_event': 'process_monitoring',
                                'severity': 'high'
                            }
                            
                            self.send_to_loki(log_entry, stream_labels)
                            
            except Exception as e:
                logging.error(f"Error checking processes: {e}")

        def check_file_integrity(self):
            """Monitor critical files for changes"""
            critical_files = [
                '/etc/passwd',
                '/etc/shadow',
                '/etc/group',
                '/etc/sudoers',
                '/etc/ssh/sshd_config',
                '/etc/crontab'
            ]
            
            for file_path in critical_files:
                try:
                    if os.path.exists(file_path):
                        stat = os.stat(file_path)
                        cache_file = f"/tmp/.{os.path.basename(file_path)}_mtime"
                        
                        if os.path.exists(cache_file):
                            with open(cache_file, 'r') as f:
                                last_mtime = float(f.read().strip())
                                
                            if stat.st_mtime != last_mtime:
                                log_entry = {
                                    'timestamp': datetime.now().isoformat(),
                                    'node': self.node_name,
                                    'event_type': 'file_integrity_change',
                                    'file_path': file_path,
                                    'new_mtime': stat.st_mtime,
                                    'old_mtime': last_mtime,
                                    'severity': 'high'
                                }
                                
                                stream_labels = {
                                    'job': 'security-monitor',
                                    'node': self.node_name,
                                    'security_event': 'file_integrity',
                                    'severity': 'high'
                                }
                                
                                self.send_to_loki(log_entry, stream_labels)
                        
                        # Update cache
                        with open(cache_file, 'w') as f:
                            f.write(str(stat.st_mtime))
                            
                except Exception as e:
                    logging.error(f"Error checking file {file_path}: {e}")

        def check_network_connections(self):
            """Monitor suspicious network connections"""
            try:
                result = subprocess.run(['netstat', '-tulpn'], capture_output=True, text=True)
                
                suspicious_ports = ['4444', '5555', '6666', '1234', '31337']
                
                for line in result.stdout.split('\n'):
                    for port in suspicious_ports:
                        if f':{port}' in line and 'LISTEN' in line:
                            log_entry = {
                                'timestamp': datetime.now().isoformat(),
                                'node': self.node_name,
                                'event_type': 'suspicious_port_listen',
                                'connection_line': line.strip(),
                                'suspicious_port': port,
                                'severity': 'high'
                            }
                            
                            stream_labels = {
                                'job': 'security-monitor',
                                'node': self.node_name,
                                'security_event': 'network_monitoring',
                                'severity': 'high'
                            }
                            
                            self.send_to_loki(log_entry, stream_labels)
                            
            except Exception as e:
                logging.error(f"Error checking network connections: {e}")

        def run_monitoring_cycle(self):
            """Run one complete monitoring cycle"""
            logging.info("Starting security monitoring cycle")
            
            self.check_package_changes()
            self.check_suspicious_processes()
            self.check_file_integrity()
            self.check_network_connections()
            
            logging.info("Security monitoring cycle completed")

        def start_monitoring(self):
            """Start the monitoring loop"""
            logging.info(f"Starting security monitor on node: {self.node_name}")
            
            while True:
                try:
                    self.run_monitoring_cycle()
                    time.sleep(60)  # Run every minute
                except KeyboardInterrupt:
                    logging.info("Security monitor stopped")
                    break
                except Exception as e:
                    logging.error(f"Error in monitoring cycle: {e}")
                    time.sleep(30)  # Wait before retrying

    if __name__ == "__main__":
        monitor = SecurityMonitor()
        monitor.start_monitoring()

  requirements.txt: |
    requests==2.31.0

---
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: security-monitor
  namespace: security
  labels:
    app: security-monitor
spec:
  selector:
    matchLabels:
      app: security-monitor
  template:
    metadata:
      labels:
        app: security-monitor
    spec:
      serviceAccountName: security-monitor
      automountServiceAccountToken: true
      hostNetwork: true
      hostPID: true
      containers:
      - name: security-monitor
        image: python:3.11-slim
        command: ["/bin/bash"]
        args:
          - -c
          - |
            apt-get update && apt-get install -y procps net-tools
            cd /app
            pip install -r requirements.txt
            python monitor.py
        env:
        - name: NODE_NAME
          valueFrom:
            fieldRef:
              fieldPath: spec.nodeName
        - name: LOKI_URL
          value: "http://loki.monitoring.svc.cluster.local:3100"
        volumeMounts:
        - name: app-code
          mountPath: /app
        - name: host-etc
          mountPath: /host/etc
          readOnly: true
        - name: host-proc
          mountPath: /host/proc
          readOnly: true
        - name: tmp-storage
          mountPath: /tmp
        resources:
          limits:
            memory: 256Mi
            cpu: 200m
            ephemeral-storage: 1Gi
          requests:
            memory: 128Mi
            cpu: 100m
            ephemeral-storage: 500Mi
        securityContext:
          privileged: true
          runAsUser: 0
      volumes:
      - name: app-code
        configMap:
          name: security-monitor-config
          defaultMode: 0755
      - name: host-etc
        hostPath:
          path: /etc
      - name: host-proc
        hostPath:
          path: /proc
      - name: tmp-storage
        emptyDir:
          sizeLimit: 1Gi
      tolerations:
      - key: node-role.kubernetes.io/control-plane
        operator: Exists
        effect: NoSchedule
      - operator: "Exists"
        effect: "NoExecute"
      - operator: "Exists"
        effect: "NoSchedule"
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: security-monitor
  namespace: security
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: security-monitor
rules:
- apiGroups: [""]
  resources: ["nodes", "pods"]
  verbs: ["get", "list", "watch"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: security-monitor
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: security-monitor
subjects:
- kind: ServiceAccount
  name: security-monitor
  namespace: security
